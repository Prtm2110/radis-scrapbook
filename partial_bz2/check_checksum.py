# -*- coding: utf-8 -*-
"""
Created on Sat Mar 22 08:44:45 2025

@author: dcmvd

This file opens the bit_shift_X.bz2 files generated by gen_bit_shifts.py,
and uncompresses them. Then the script calculates the stream and block crc's
and compares these with the stored ones. When we have the same outputs,
the functions generating the CRC's are validated.

"""

import numpy as np
import bz2
from binascii import crc32


fname = 'bit_shifts/bit_shift_{:0}.bz2'

def calc_block_crc(data):
    arr = np.frombuffer(data, dtype = np.uint8)
    
    #Flip bits:
    arr = ((arr & 0b01010101) << 1) | ((arr & 0b10101010) >> 1) 
    arr = ((arr & 0b00110011) << 2) | ((arr & 0b11001100) >> 2)
    arr = ((arr & 0b00001111) << 4) | ((arr & 0b11110000) >> 4)
    
    #CRC:
    res = crc32(arr)
    
    #Flip bits back:
    res = int('{:032b}'.format(res)[::-1], 2)
    return res 



class StreamCRC:
    def __init__(self):
        self.strmCRC = 0
        
    def update(self, blkCRC):
        self.strmCRC = blkCRC ^ ((self.strmCRC<<1) | (self.strmCRC>>31)) 
    
    def result(self):
        return self.strmCRC & 0xffffffff

#%% First get the bitstream of the eos marker:
eos_marker = 0x177245385090
eos_bits = bin(eos_marker)[2:]
pad = (len(eos_bits)-2) % 8
eos_bits = pad*'0' + eos_bits



for i in range(8):

    stream_crc = StreamCRC()
    
    with open(fname.format(i), 'rb') as fr:
        buf = fr.read()
    
    data = bz2.decompress(buf)
    
    crc = calc_block_crc(data)
    print('\n',i)
    print(crc.to_bytes(4))
    
    stream_crc.update(crc)
    
    stream_header = buf[:4]
    block_magic = buf[4:10]
    block_crc = buf[10:14]

    print(block_crc)
    
    pad = 8-i if i else 0
    size = 5 if i else 4
    
    print('  my crc: {:040b}'.format(stream_crc.result()<<i))
    print('file crc: {:040b}'.format(int.from_bytes(buf[-size:])))
    print('          '+(8-i)*'-'+32*'x'+(i)*'-')
    
    
    
    
    